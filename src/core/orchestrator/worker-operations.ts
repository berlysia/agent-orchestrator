/**
 * Worker Operations - ã‚¿ã‚¹ã‚¯å®Ÿè£…ã‚’æ‹…å½“ã™ã‚‹é–¢æ•°ç¾¤
 *
 * Workerã‚¯ãƒ©ã‚¹ã‚’é–¢æ•°å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å†å®Ÿè£…ã€‚
 * ã‚¿ã‚¹ã‚¯ã”ã¨ã«worktreeã‚’ä½œæˆã—ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å®Ÿè¡Œã—ã¦å®Ÿè£…ã‚’è¡Œã†ã€‚
 */

import path from 'node:path';
import { spawn } from 'node:child_process';
import type { Result } from 'option-t/plain_result';
import { createOk, createErr, isErr } from 'option-t/plain_result';
import type { Task } from '../../types/task.ts';
import type { TaskId, WorktreePath, RepoPath, BranchName } from '../../types/branded.ts';
import { runId, repoPath } from '../../types/branded.ts';
import type { GitEffects } from '../../adapters/vcs/git-effects.ts';
import type { RunnerEffects } from '../runner/runner-effects.ts';
import type { TaskStore } from '../task-store/interface.ts';
import type { OrchestratorError } from '../../types/errors.ts';
import { createInitialRun, RunStatus } from '../../types/run.ts';
import type { Config } from '../../types/config.ts';
import type { ConflictContent, ConflictResolutionInfo } from '../../types/integration.ts';
import type { BaseBranchResolution } from './base-branch-resolver.ts';

/**
 * Worktreeä½œæˆçµæœ
 *
 * WHY: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒã‚ã‚‹å ´åˆã‚‚ worktree ã¯ä½œæˆã•ã‚Œã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãçŠ¶æ…‹ã¨ã—ã¦è¿”ã™
 */
export type WorktreeSetupResult =
  | { type: 'success'; worktreePath: WorktreePath }
  | { type: 'with_conflicts'; worktreePath: WorktreePath; conflictInfo: ConflictResolutionInfo };

/**
 * Workerä¾å­˜é–¢ä¿‚
 */
export interface WorkerDeps {
  readonly gitEffects: GitEffects;
  readonly runnerEffects: RunnerEffects;
  readonly taskStore: TaskStore;
  readonly appRepoPath: RepoPath;
  readonly agentCoordPath: string;
  readonly agentType: 'claude' | 'codex';
  readonly model: string;
  readonly config: Config;
}

/**
 * Workerå®Ÿè¡Œçµæœ
 */
export interface WorkerResult {
  /** å®Ÿè¡ŒID */
  readonly runId: string;
  /** æˆåŠŸã—ãŸã‹ */
  readonly success: boolean;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå¤±æ•—æ™‚ï¼‰ */
  readonly error?: string;
}

/**
 * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç¨®åˆ¥
 */
export type AgentType = 'claude' | 'codex';

/**
 * è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã®åˆ¤å®š
 *
 * WHY: node_modules/ã‚„lockãƒ•ã‚¡ã‚¤ãƒ«ã¯LLMã«ã‚ˆã‚‹è§£æ±ºãŒä¸é©åˆ‡ãªãŸã‚ã€ç‰¹åˆ¥æ‰±ã„ãŒå¿…è¦
 */
const isAutoGeneratedFile = (filePath: string): boolean => {
  const autoGeneratedPatterns = [
    // ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒ•ã‚¡ã‚¤ãƒ«
    /^node_modules\//,
    /^\.pnpm\//,
    /pnpm-lock\.yaml$/,
    /package-lock\.json$/,
    /yarn\.lock$/,
    // ãƒ“ãƒ«ãƒ‰å‡ºåŠ›
    /^dist\//,
    /^build\//,
    /^\.next\//,
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    /^\.cache\//,
    /^\.turbo\//,
  ];

  return autoGeneratedPatterns.some((pattern) => pattern.test(filePath));
};

/**
 * ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã®åˆ¤å®š
 *
 * WHY: ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•è§£æ±ºä¸å¯èƒ½ãªãŸã‚ã€äº‹å‰ã«ãƒã‚§ãƒƒã‚¯ã™ã‚‹
 */
const isBinaryFile = (filePath: string): boolean => {
  const binaryExtensions = [
    // ç”»åƒ
    '.png',
    '.jpg',
    '.jpeg',
    '.gif',
    '.bmp',
    '.ico',
    '.webp',
    '.svg',
    // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
    '.pdf',
    '.doc',
    '.docx',
    '.xls',
    '.xlsx',
    '.ppt',
    '.pptx',
    // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    '.zip',
    '.tar',
    '.gz',
    '.rar',
    '.7z',
    // ãƒã‚¤ãƒŠãƒªå®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«
    '.exe',
    '.dll',
    '.so',
    '.dylib',
    // ãã®ä»–
    '.bin',
    '.dat',
    '.db',
    '.sqlite',
  ];
  const ext = path.extname(filePath).toLowerCase();
  return binaryExtensions.includes(ext);
};

/**
 * è‡ªå‹•è§£æ±ºã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã¹ãã‹åˆ¤å®š
 *
 * WHY: ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ãƒ»è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ»æ‹¡å¼µå­ãªã—å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã¯
 *      LLMã«ã‚ˆã‚‹è§£æ±ºãŒä¸é©åˆ‡ã¾ãŸã¯ä¸å¯èƒ½ãªãŸã‚ã€è‡ªå‹•è§£æ±ºå¯¾è±¡ã‹ã‚‰é™¤å¤–
 */
/**
 * ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
 *
 * WHY: pnpm install ãªã©ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */
const runCommand = (
  cwd: string,
  command: string,
  args: string[],
): Promise<Result<string, Error>> => {
  return new Promise((resolve) => {
    const proc = spawn(command, args, { cwd, shell: true });
    let stdout = '';
    let stderr = '';

    proc.stdout?.on('data', (data: Buffer) => {
      stdout += data.toString();
    });

    proc.stderr?.on('data', (data: Buffer) => {
      stderr += data.toString();
    });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve(createOk(stdout));
      } else {
        resolve(createErr(new Error(`Command failed with code ${code}: ${stderr}`)));
      }
    });

    proc.on('error', (err) => {
      resolve(createErr(err));
    });
  });
};

export const shouldSkipAutoResolution = (
  filePath: string,
): { skip: boolean; reason: string; isLockfile: boolean; isNodeModules: boolean } => {
  // Lockãƒ•ã‚¡ã‚¤ãƒ«ã®åˆ¤å®š
  const isLockfile =
    filePath.endsWith('pnpm-lock.yaml') ||
    filePath.endsWith('package-lock.json') ||
    filePath.endsWith('yarn.lock');

  // node_modulesé…ä¸‹ã®åˆ¤å®š
  const isNodeModules = filePath.startsWith('node_modules/') || filePath.startsWith('.pnpm/');

  // è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«
  if (isAutoGeneratedFile(filePath)) {
    return { skip: true, reason: 'auto-generated file', isLockfile, isNodeModules };
  }

  // ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«
  if (isBinaryFile(filePath)) {
    return { skip: true, reason: 'binary file', isLockfile: false, isNodeModules: false };
  }

  // æ‹¡å¼µå­ãªã—ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆnode_modules/.bin/* ãªã©ï¼‰
  const ext = path.extname(filePath);
  if (ext === '' && filePath.includes('/.bin/')) {
    return { skip: true, reason: 'executable without extension', isLockfile: false, isNodeModules };
  }

  return { skip: false, reason: '', isLockfile: false, isNodeModules: false };
};

/**
 * ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆï¼ˆç´”ç²‹é–¢æ•°ï¼‰
 */
export const generateCommitMessage = (task: Task): string => {
  return `feat: ${task.acceptance}

Task ID: ${task.id}
Branch: ${task.branch}

ğŸ¤– Generated with Agent Orchestrator
`;
};

/**
 * Workeræ“ä½œã‚’ç”Ÿæˆã™ã‚‹ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°
 */
export const createWorkerOperations = (deps: WorkerDeps) => {
  const toRelativePath = (targetPath: string): string => {
    const absolutePath = path.resolve(targetPath);
    const relativePath = path.relative(process.cwd(), absolutePath);
    return relativePath === '' ? '.' : relativePath;
  };

  const getRunDisplayPath = (runIdValue: string, ext: 'log' | 'json'): string => {
    return toRelativePath(path.join(deps.agentCoordPath, 'runs', `${runIdValue}.${ext}`));
  };

  /**
   * ã‚¿ã‚¹ã‚¯ç”¨ã®worktreeã‚’ä½œæˆ
   *
   * ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆã—ã¾ã™ã€‚
   *
   * WHY: ãƒ–ãƒ©ãƒ³ãƒåã«ã‚¿ã‚¹ã‚¯IDã‚’å«ã‚ã‚‹ã“ã¨ã§ã€ä¸¦åˆ—å®Ÿè¡Œæ™‚ã®è¡çªã‚’é˜²ã
   * ä¾‹: feature/auth â†’ feature/auth-task-2b8c0253-1
   *
   * WHY: Phase 2 - çµ±åˆãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰å†å®Ÿè¡Œã™ã‚‹å ´åˆã€æ–°ã—ã„worktreeã‚’ä½œæˆ
   *      å…ƒã®worktreeã¯å…ƒã®ãƒ–ãƒ©ãƒ³ãƒã‚’æŒ‡ã—ã¦ã„ã‚‹ãŸã‚ã€rebaseã«ã‚ˆã‚‹ãƒ–ãƒ©ãƒ³ãƒåˆ‡ã‚Šæ›¿ãˆã¯ãƒªã‚¹ã‚¯ãŒé«˜ã„
   *      æ–°ã—ã„worktreeã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã€å…ƒã®ãƒ–ãƒ©ãƒ³ãƒã®çŠ¶æ…‹ã‚’ä¿æŒã—ã¤ã¤ã€çµ±åˆãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰å®Ÿè¡Œå¯èƒ½
   *
   * @param task ã‚¿ã‚¹ã‚¯
   * @param baseBranch èµ·ç‚¹ã¨ãªã‚‹ãƒ–ãƒ©ãƒ³ãƒï¼ˆæ–°è¦ãƒ–ãƒ©ãƒ³ãƒä½œæˆæ™‚ã®ã¿ä½¿ç”¨ï¼‰
   * @returns worktreeã®ãƒ‘ã‚¹ï¼ˆResultå‹ï¼‰
   */
  const setupWorktree = async (
    task: Task,
    baseBranch?: BranchName,
  ): Promise<Result<WorktreePath, OrchestratorError>> => {
    // ã‚¿ã‚¹ã‚¯ã®ãƒ–ãƒ©ãƒ³ãƒåã‚’å–å¾—ï¼ˆPlannerãŒæ—¢ã«ã‚¿ã‚¹ã‚¯IDã‚’å«ã‚ã¦ã„ã‚‹ï¼‰
    const taskBranchName = task.branch;

    // ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
    const branchesResult = await deps.gitEffects.listBranches(deps.appRepoPath);
    if (isErr(branchesResult)) {
      return createErr(branchesResult.err);
    }

    const branches = branchesResult.val;
    const branchExists = branches.some((b) => b.name === taskBranchName);

    // WHY: Phase 2 - çµ±åˆãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰å†å®Ÿè¡Œã™ã‚‹å ´åˆã€æ–°ã—ã„worktreeåã‚’ä½¿ç”¨
    //      å…ƒã®worktreeã¨åŒºåˆ¥ã™ã‚‹ãŸã‚ã€ã‚µãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ 
    const worktreeName = task.integrationRetried
      ? `${task.id}-integration`
      : String(task.id);

    // Worktreeã‚’ä½œæˆï¼ˆcreateBranchãƒ•ãƒ©ã‚°ã§ãƒ–ãƒ©ãƒ³ãƒã‚‚åŒæ™‚ä½œæˆï¼‰
    // WHY: baseBranchæŒ‡å®šæ™‚ã¯ã€ãã®ãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰åˆ†å²ï¼ˆä¾å­˜é–¢ä¿‚ã‚’åæ˜ ï¼‰
    const worktreeResult = await deps.gitEffects.createWorktree(
      deps.appRepoPath,
      worktreeName,
      taskBranchName,
      !branchExists,
      baseBranch,
    );

    return worktreeResult;
  };

  /**
   * ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ¶ˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰ï¼ˆã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è§£æ±ºç”¨ï¼‰
   *
   * WHY: Workerå®Ÿè¡Œä¸­ã«ãã®å ´ã§ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’è§£æ±ºã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
   *
   * @param conflictInfo ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæƒ…å ±
   * @returns ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡å­—åˆ—
   */
  const buildConflictResolutionPromptInline = (conflictInfo: ConflictResolutionInfo): string => {
    const lines: string[] = [
      '# âš ï¸  Merge Conflict Resolution Required',
      '',
      'Before executing your main task, you must resolve merge conflicts that occurred',
      'while merging dependency branches.',
      '',
      `Source branch: ${conflictInfo.sourceBranch}`,
      `Target branch: ${conflictInfo.targetBranch}`,
      '',
      'The following merge conflicts must be resolved:',
      '',
    ];

    for (const detail of conflictInfo.conflictContents) {
      lines.push(`## File: ${detail.filePath}`);
      lines.push(`Conflicting branch: ${detail.theirBranch}`);
      lines.push('');
      lines.push('### Our version (current branch):');
      lines.push('```');
      lines.push(detail.oursContent);
      lines.push('```');
      lines.push('');
      lines.push('### Their version (incoming branch):');
      lines.push('```');
      lines.push(detail.theirsContent);
      lines.push('```');
      lines.push('');
      if (detail.baseContent) {
        lines.push('### Base version (common ancestor):');
        lines.push('```');
        lines.push(detail.baseContent);
        lines.push('```');
        lines.push('');
      }
    }

    lines.push('## Instructions');
    lines.push('');
    lines.push('1. Analyze both versions and understand the intent of each change');
    lines.push('2. Resolve conflicts by choosing appropriate content or merging both changes');
    lines.push('3. Edit the conflicted files to resolve all conflicts');
    lines.push(
      '4. Ensure the resolved code compiles and maintains functionality from both versions',
    );
    lines.push('5. DO NOT commit - the orchestrator will commit after resolution');
    lines.push('');
    lines.push('After resolving all conflicts, your main task will be executed.');

    return lines.join('\n');
  };

  /**
   * è¤‡æ•°ä¾å­˜ã‚¿ã‚¹ã‚¯ç”¨ã®worktreeã‚’ä½œæˆã—ã€ä¾å­˜ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒãƒ¼ã‚¸
   *
   * WHY: ãƒ¡ã‚¤ãƒ³ãƒªãƒã‚¸ãƒˆãƒªã®HEADã‚’å¤‰æ›´ã›ãšã€worktreeå†…ã§ãƒãƒ¼ã‚¸ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§
   *      ä¸¦åˆ—å®Ÿè¡Œæ™‚ã®Gitæ“ä½œç«¶åˆã‚’é˜²ã
   *
   * WHY: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆç™ºç”Ÿæ™‚ã‚‚ worktree ã¯ä½œæˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã§ã¯ãªã
   *      ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæƒ…å ±ä»˜ãã®çµæœã¨ã—ã¦è¿”ã™
   *
   * @param task ã‚¿ã‚¹ã‚¯
   * @param dependencyBranches ä¾å­˜ãƒ–ãƒ©ãƒ³ãƒã®ãƒªã‚¹ãƒˆ
   * @returns worktreeä½œæˆçµæœï¼ˆã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæƒ…å ±ã‚’å«ã‚€å¯èƒ½æ€§ã‚ã‚Šï¼‰
   */
  const setupWorktreeWithMerge = async (
    task: Task,
    dependencyBranches: readonly BranchName[],
  ): Promise<Result<WorktreeSetupResult, OrchestratorError>> => {
    if (dependencyBranches.length === 0) {
      return createErr({
        type: 'ValidationError',
        details: 'dependencyBranches must not be empty',
        message: 'setupWorktreeWithMerge called with empty dependencyBranches',
      });
    }

    // 1. æœ€åˆã®ä¾å­˜ãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰worktreeä½œæˆ
    const firstBranch = dependencyBranches[0]!;
    const worktreeResult = await setupWorktree(task, firstBranch);
    if (isErr(worktreeResult)) {
      return createErr(worktreeResult.err);
    }

    const worktreePath = worktreeResult.val;

    // ä¾å­˜ãŒ1ã¤ã ã‘ã®å ´åˆã¯ãƒãƒ¼ã‚¸ä¸è¦
    if (dependencyBranches.length === 1) {
      return createOk({ type: 'success', worktreePath });
    }

    const mergedBranches: BranchName[] = [firstBranch];

    // 2. worktreeå†…ã§æ®‹ã‚Šã®ä¾å­˜ãƒ–ãƒ©ãƒ³ãƒã‚’é †æ¬¡ãƒãƒ¼ã‚¸
    for (let i = 1; i < dependencyBranches.length; i++) {
      const branchToMerge = dependencyBranches[i]!;
      const mergeResult = await deps.gitEffects.merge(repoPath(worktreePath), branchToMerge);

      if (isErr(mergeResult)) {
        // ãƒãƒ¼ã‚¸ã‚¨ãƒ©ãƒ¼: ãƒãƒ¼ã‚¸ã‚’ä¸­æ–­ã—ã€worktreeã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¦ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
        await deps.gitEffects.abortMerge(repoPath(worktreePath));
        await cleanupWorktree(task.id);
        return createErr(mergeResult.err);
      }

      const merge = mergeResult.val;

      if (merge.hasConflicts) {
        // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆç™ºç”Ÿ: ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«åˆ†é¡ã—ã¦å‡¦ç†
        // WHY: Workerè‡ªèº«ãŒãã®å ´ã§è§£æ±ºã™ã‚‹ã“ã¨ã§ã€ã‚¿ã‚¹ã‚¯å¤±æ•—â†’ä¾å­˜ãƒ–ãƒ­ãƒƒã‚¯ã®é€£é–ã‚’é˜²ã

        const lockfileConflicts: string[] = [];
        const nodeModulesConflicts: string[] = [];
        const binaryConflicts: string[] = [];
        const textConflicts: string[] = [];

        for (const conflict of merge.conflicts) {
          const resolution = shouldSkipAutoResolution(conflict.filePath);
          if (resolution.isLockfile) {
            lockfileConflicts.push(conflict.filePath);
          } else if (resolution.isNodeModules) {
            nodeModulesConflicts.push(conflict.filePath);
          } else if (resolution.skip && resolution.reason === 'binary file') {
            binaryConflicts.push(conflict.filePath);
          } else if (!resolution.skip) {
            textConflicts.push(conflict.filePath);
          } else {
            // ãã®ä»–ã®è‡ªå‹•è§£æ±ºã‚¹ã‚­ãƒƒãƒ—å¯¾è±¡ï¼ˆæ‹¡å¼µå­ãªã—å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ãªã©ï¼‰
            nodeModulesConflicts.push(conflict.filePath);
          }
        }

        // ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒå«ã¾ã‚Œã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼
        if (binaryConflicts.length > 0) {
          console.log(
            `  âš ï¸  Binary file conflicts detected: ${binaryConflicts.join(', ')} (cannot auto-resolve)`,
          );
          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr({
            type: 'ValidationError',
            message: `Cannot auto-resolve binary file conflicts: ${binaryConflicts.join(', ')}`,
            details: 'Binary files require manual conflict resolution',
          });
        }

        // Phase 3: lockfile/node_modulesã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’è‡ªå‹•è§£æ±º
        const autoResolvedCount = lockfileConflicts.length + nodeModulesConflicts.length;
        if (autoResolvedCount > 0) {
          console.log(`  ğŸ”§ Auto-resolving ${autoResolvedCount} generated file conflicts`);

          for (const filePath of [...lockfileConflicts, ...nodeModulesConflicts]) {
            // --ours ã‚’æ¡ç”¨ï¼ˆã©ã¡ã‚‰ã§ã‚‚è‰¯ã„ã€å¾Œã§å†ç”Ÿæˆã•ã‚Œã‚‹ï¼‰
            const checkoutResult = await deps.gitEffects.raw?.(
              repoPath(worktreePath),
              ['checkout', '--ours', filePath],
            );
            if (checkoutResult && !checkoutResult.ok) {
              console.log(`  âš ï¸  Failed to checkout --ours for ${filePath}: ${checkoutResult.err.message}`);
            }

            const markResult = await deps.gitEffects.markConflictResolved(
              repoPath(worktreePath),
              filePath,
            );
            if (!markResult.ok) {
              console.log(`  âš ï¸  Failed to mark ${filePath} as resolved: ${markResult.err.message}`);
            }
          }
        }

        // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã®ã¿ã‚’Workerã«ä»»ã›ã‚‹
        if (textConflicts.length > 0) {
          const conflictDetails: ConflictContent[] = [];

          for (const filePath of textConflicts) {
            const contentResult = await deps.gitEffects.getConflictContent(
              repoPath(worktreePath),
              filePath,
            );
            if (contentResult.ok) {
              conflictDetails.push(contentResult.val);
            }
          }

          // ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒã‚ã‚‹å ´åˆã¯Workerã«è§£æ±ºã‚’ä¾é ¼
          const conflictInfo: ConflictResolutionInfo = {
            taskId: task.id,
            sourceBranch: branchToMerge,
            targetBranch: task.branch,
            conflicts: merge.conflicts.filter((c) => textConflicts.includes(c.filePath)),
            conflictContents: conflictDetails,
            // Phase 4: è‡ªå‹•è§£æ±ºã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã€å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå¿…è¦
            needsReinstall: autoResolvedCount > 0,
          };

          return createOk({
            type: 'with_conflicts',
            worktreePath,
            conflictInfo,
          });
        }

        // è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã®ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã ã£ãŸå ´åˆ
        if (autoResolvedCount > 0 && textConflicts.length === 0) {
          console.log(`  âœ… All conflicts were auto-resolved (generated files only)`);

          // ã‚³ãƒŸãƒƒãƒˆã—ã¦ç¶šè¡Œ
          const commitResult = await deps.gitEffects.commit(
            repoPath(worktreePath),
            'Resolve generated file conflicts (auto-resolved)',
            { noGpgSign: !deps.config.commit.autoSignature },
          );

          if (!commitResult.ok) {
            // ã‚³ãƒŸãƒƒãƒˆå¤±æ•—æ™‚ã¯ãƒãƒ¼ã‚¸ã‚’ä¸­æ–­ã—ã¦ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
            // WHY: ãƒãƒ¼ã‚¸çŠ¶æ…‹ãŒæ®‹ã£ãŸã¾ã¾æ¬¡ã®ãƒãƒ¼ã‚¸ã«é€²ã‚€ã¨Gitã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
            console.log(`  âŒ Failed to commit auto-resolved conflicts: ${commitResult.err.message}`);
            await deps.gitEffects.abortMerge(repoPath(worktreePath));
            await cleanupWorktree(task.id);
            return createErr(commitResult.err);
          }

          console.log(`  âœ… Auto-resolved conflicts committed`);
          // ãƒãƒ¼ã‚¸æˆåŠŸã¨ã—ã¦æ‰±ã†ï¼ˆæ¬¡ã®ãƒ–ãƒ©ãƒ³ãƒã®ãƒãƒ¼ã‚¸ã«é€²ã‚€ï¼‰
          mergedBranches.push(branchToMerge);
          continue;
        }
      }

      mergedBranches.push(branchToMerge);
    }

    // å…¨ã¦ã®ãƒãƒ¼ã‚¸ãŒæˆåŠŸ
    return createOk({ type: 'success', worktreePath });
  };

  /**
   * ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œã®ã¿ï¼‰
   *
   * ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’èµ·å‹•ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
   * å®Ÿè¡Œãƒ­ã‚°ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’runsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¿å­˜ã—ã¾ã™ã€‚
   * Gitæ“ä½œï¼ˆcommitã€pushï¼‰ã¯åˆ¥ã®é–¢æ•°ã§è¡Œã„ã¾ã™ã€‚
   *
   * @param task ã‚¿ã‚¹ã‚¯
   * @param worktreePath worktreeã®ãƒ‘ã‚¹
   * @returns å®Ÿè¡Œçµæœï¼ˆrunIdã¨æˆåŠŸ/å¤±æ•—ï¼‰
   */
  const executeTask = async (
    task: Task,
    worktreePath: WorktreePath,
  ): Promise<Result<WorkerResult, OrchestratorError>> => {
    // 1. runsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç¢ºä¿
    const ensureResult = await deps.runnerEffects.ensureRunsDir();
    if (isErr(ensureResult)) {
      return createErr(ensureResult.err);
    }

    // 2. RunIDç”Ÿæˆï¼ˆã‚¿ã‚¹ã‚¯IDãƒ™ãƒ¼ã‚¹ï¼‰
    const timestamp = Date.now();
    const theRunId = runId(`run-${task.id}-${timestamp}`);
    const logPath = path.join(deps.agentCoordPath, 'runs', `${theRunId}.log`);

    // 3. å®Ÿè¡Œãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
    const run = createInitialRun({
      id: theRunId,
      taskId: task.id,
      agentType: deps.agentType,
      logPath,
      plannerRunId: task.plannerRunId ?? null,
      plannerLogPath: task.plannerLogPath ?? null,
      plannerMetadataPath: task.plannerMetadataPath ?? null,
    });

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä¿å­˜
    const saveMetaResult = await deps.runnerEffects.saveRunMetadata(run);
    if (isErr(saveMetaResult)) {
      return createErr(saveMetaResult.err);
    }

    // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’åˆæœŸåŒ–
    const initLogResult = await deps.runnerEffects.initializeLogFile(run);
    if (isErr(initLogResult)) {
      return createErr(initLogResult.err);
    }

    console.log(`  ğŸ“ Execution log: ${getRunDisplayPath(theRunId, 'log')}`);
    console.log(`  ğŸ“Š Metadata: ${getRunDisplayPath(theRunId, 'json')}`);

    // 4. ãƒ­ã‚°ã«ã‚¿ã‚¹ã‚¯é–‹å§‹ã‚’è¨˜éŒ²
    await deps.runnerEffects.appendLog(
      theRunId,
      `[${new Date().toISOString()}] Starting task: ${task.acceptance}\n`,
    );
    await deps.runnerEffects.appendLog(theRunId, `Agent Type: ${deps.agentType}\n`);
    await deps.runnerEffects.appendLog(theRunId, `Worktree: ${worktreePath}\n\n`);

    // 5. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å®Ÿè¡Œ
    // WHY: å½¹å‰²ã”ã¨ã«æœ€é©ãªãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ï¼ˆConfig ã‹ã‚‰å–å¾—ï¼‰
    // WHY: task.context ã«ã¯è©³ç´°ãªå®Ÿè£…æŒ‡ç¤ºãŒå«ã¾ã‚Œã‚‹ãŸã‚ã€å¿…ãšãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å«ã‚ã‚‹
    let agentPrompt = `Execute task: ${task.acceptance}

${task.context ? `## IMPLEMENTATION DETAILS\n${task.context}\n` : ''}
${task.scopePaths.length > 0 ? `## FILES TO CREATE/MODIFY\n${task.scopePaths.join('\n')}\n` : ''}

âš ï¸  CRITICAL: You must IMPLEMENT the task, not just verify it.
- CREATE or MODIFY the files listed above
- If files already exist, verify they meet requirements OR update them
- Ensure your changes are saved and ready to be committed
- The "VERIFY" section describes how to validate completion, not the entire task

âš ï¸  IMPORTANT: You are working in an isolated worktree directory.
- Your working directory is: ${worktreePath}
- DO NOT use 'cd ..' or navigate outside this directory
- All work must be done within this directory
- The worktree is properly configured with the correct branch

âš ï¸  IMPORTANT: DO NOT create report files in the repository
- DO NOT create VERIFICATION_REPORT.md or any other report files
- Output verification results directly to logs (stdout/stderr)
- Use console.log, console.error for verification output
- Reports are automatically saved to the runs/ directory by the orchestrator`;

    // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãŒã‚ã‚‹å ´åˆã¯è¿½åŠ ï¼ˆç¶™ç¶šå®Ÿè¡Œã®ãŸã‚ï¼‰
    // WHY: å‰å›ã®åˆ¤å®šã§æŒ‡æ‘˜ã•ã‚ŒãŸå•é¡Œã‚’æ˜ç¤ºã™ã‚‹ã“ã¨ã§ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒé©åˆ‡ã«å¯¾å‡¦ã§ãã‚‹
    if (task.judgementFeedback) {
      agentPrompt += `\n\nâš ï¸  Previous attempt (iteration ${task.judgementFeedback.iteration}/${task.judgementFeedback.maxIterations}):`;
      agentPrompt += `\nReason: ${task.judgementFeedback.lastJudgement.reason}`;
      if (task.judgementFeedback.lastJudgement.missingRequirements.length > 0) {
        agentPrompt += `\n\nMissing requirements:`;
        for (const req of task.judgementFeedback.lastJudgement.missingRequirements) {
          agentPrompt += `\n  - ${req}`;
        }
      }
      agentPrompt += `\n\nPlease address these issues and complete the task.`;
    }

    const agentResult =
      deps.agentType === 'claude'
        ? await deps.runnerEffects.runClaudeAgent(agentPrompt, worktreePath as string, deps.model!, theRunId)
        : await deps.runnerEffects.runCodexAgent(agentPrompt, worktreePath as string, deps.model, theRunId);

    // 6. çµæœã‚’ãƒ­ã‚°ã«è¨˜éŒ²
    if (isErr(agentResult)) {
      const errorMsg = agentResult.err.message;
      await deps.runnerEffects.appendLog(
        theRunId,
        `[${new Date().toISOString()}] âŒ Agent execution failed\n`,
      );
      await deps.runnerEffects.appendLog(theRunId, `Error: ${errorMsg}\n`);

      // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆå¤±æ•—ï¼‰
      const failedRun = {
        ...run,
        status: RunStatus.FAILURE,
        finishedAt: new Date().toISOString(),
        errorMessage: errorMsg,
      };
      await deps.runnerEffects.saveRunMetadata(failedRun);

      return createOk({
        runId: theRunId,
        success: false,
        error: errorMsg,
      });
    }

    // 7. æˆåŠŸæ™‚ã®å‡¦ç†
    const output = agentResult.val;

    await deps.runnerEffects.appendLog(
      theRunId,
      `[${new Date().toISOString()}] âœ… Agent execution completed\n`,
    );
    await deps.runnerEffects.appendLog(theRunId, `Final Response:\n${output.finalResponse}\n`);

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆæˆåŠŸï¼‰
    const completedRun = {
      ...run,
      status: RunStatus.SUCCESS,
      finishedAt: new Date().toISOString(),
    };
    await deps.runnerEffects.saveRunMetadata(completedRun);

    return createOk({
      runId: theRunId,
      success: true,
    });
  };

  /**
   * å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
   *
   * WHY: config.commit.autoSignatureã§è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆæ™‚ã®ç½²åã‚’åˆ¶å¾¡ã€‚
   *      Workerå®Ÿè¡Œæ™‚ã®å„ã‚¿ã‚¹ã‚¯ã‚³ãƒŸãƒƒãƒˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ç½²åãªã—ï¼ˆé–‹ç™ºåŠ¹ç‡é‡è¦–ï¼‰ã€‚
   *
   * @param task ã‚¿ã‚¹ã‚¯
   * @param worktreePath worktreeã®ãƒ‘ã‚¹
   * @returns Resultå‹
   */
  const commitChanges = async (
    task: Task,
    worktreePath: WorktreePath,
  ): Promise<Result<void, OrchestratorError>> => {
    // å¤‰æ›´ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
    const stageResult = await deps.gitEffects.stageAll(worktreePath);
    if (isErr(stageResult)) {
      return createErr(stageResult.err);
    }

    // ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
    const commitMessage = generateCommitMessage(task);

    // ã‚³ãƒŸãƒƒãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®šï¼ˆç½²ååˆ¶å¾¡ï¼‰
    const noGpgSign = !deps.config.commit.autoSignature;

    // ã‚³ãƒŸãƒƒãƒˆ
    const commitResult = await deps.gitEffects.commit(worktreePath, commitMessage, { noGpgSign });
    if (isErr(commitResult)) {
      return createErr(commitResult.err);
    }

    return createOk(undefined);
  };

  /**
   * ãƒªãƒ¢ãƒ¼ãƒˆã«push
   *
   * WHY: worktreeã®ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒåã‚’å–å¾—ã—ã¦pushã™ã‚‹ã“ã¨ã§ã€serial chainå®Ÿè¡Œæ™‚ã®
   *      ãƒ–ãƒ©ãƒ³ãƒåã®ä¸ä¸€è‡´ã‚’é˜²ãï¼ˆæœ€åˆã®ã‚¿ã‚¹ã‚¯ã®ãƒ–ãƒ©ãƒ³ãƒåã‚’ä½¿ç”¨ï¼‰
   * WHY: ãƒªãƒ¢ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯pushã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒã¸ã®å¯¾å¿œï¼‰
   *
   * @param worktreePath worktreeã®ãƒ‘ã‚¹
   * @returns Resultå‹
   */
  const pushChanges = async (
    worktreePath: WorktreePath,
  ): Promise<Result<void, OrchestratorError>> => {
    // ãƒªãƒ¢ãƒ¼ãƒˆã®å­˜åœ¨ã‚’ç¢ºèª
    const hasRemoteResult = await deps.gitEffects.hasRemote(worktreePath, 'origin');
    if (isErr(hasRemoteResult)) {
      return createErr(hasRemoteResult.err);
    }

    if (!hasRemoteResult.val) {
      // ãƒªãƒ¢ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯è­¦å‘Šã‚’è¡¨ç¤ºã—ã¦ã‚¹ã‚­ãƒƒãƒ—
      console.warn(`  âš ï¸  Remote 'origin' not found, skipping push`);
      return createOk(undefined);
    }

    // worktreeã®ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒåã‚’å–å¾—
    const currentBranchResult = await deps.gitEffects.getCurrentBranch(repoPath(worktreePath));
    if (isErr(currentBranchResult)) {
      return createErr(currentBranchResult.err);
    }

    const currentBranch = currentBranchResult.val;
    const pushResult = await deps.gitEffects.push(worktreePath, 'origin', currentBranch);

    if (isErr(pushResult)) {
      return createErr(pushResult.err);
    }

    return createOk(undefined);
  };

  /**
   * Worktreeã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆå‰Šé™¤ï¼‰
   *
   * WHY: 3.3 ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ - ã‚¿ã‚¹ã‚¯å®Œäº†å¾Œã®worktreeå‰Šé™¤ï¼ˆé€šå¸¸ã¨çµ±åˆãƒ–ãƒ©ãƒ³ãƒç”¨ï¼‰
   *
   * @param taskId ã‚¿ã‚¹ã‚¯ID
   * @returns Resultå‹
   */
  const cleanupWorktree = async (taskId: TaskId): Promise<Result<void, OrchestratorError>> => {
    // ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’å–å¾—ã—ã¦ integrationRetried ãƒ•ãƒ©ã‚°ã‚’ç¢ºèª
    const taskResult = await deps.taskStore.readTask(taskId);

    // é€šå¸¸ã®worktreeã‚’å‰Šé™¤
    const removeResult = await deps.gitEffects.removeWorktree(deps.appRepoPath, taskId);

    // çµ±åˆãƒ–ãƒ©ãƒ³ãƒç”¨ã®worktreeï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã‚‚å‰Šé™¤
    if (taskResult.ok && taskResult.val.integrationRetried) {
      const integrationWorktreeName = `${String(taskId)}-integration`;
      const removeIntegrationResult = await deps.gitEffects.removeWorktree(
        deps.appRepoPath,
        integrationWorktreeName,
      );

      if (isErr(removeIntegrationResult)) {
        // çµ±åˆworktreeã®å‰Šé™¤å¤±æ•—ã¯è­¦å‘Šã®ã¿ï¼ˆé€šå¸¸worktreeã®å‰Šé™¤çµæœã‚’å„ªå…ˆï¼‰
        console.warn(
          `Failed to remove integration worktree ${integrationWorktreeName}: ${removeIntegrationResult.err.message}`,
        );
      }
    }

    return removeResult;
  };

  /**
   * æ—¢å­˜ã®worktreeã§ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
   *
   * WHY: ç›´åˆ—ãƒã‚§ãƒ¼ãƒ³ã®ã‚¿ã‚¹ã‚¯ã¯åŒã˜worktreeã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã§ã€å‰ã®ã‚¿ã‚¹ã‚¯ã®å¤‰æ›´ã‚’å¼•ãç¶™ã’ã‚‹
   *
   * @param task ã‚¿ã‚¹ã‚¯
   * @param worktreePath æ—¢å­˜ã®worktreeãƒ‘ã‚¹
   * @param previousFeedback å‰ã®ã‚¿ã‚¹ã‚¯ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆä»»æ„ï¼‰
   * @returns å®Ÿè¡Œçµæœ
   */
  const executeTaskInExistingWorktree = async (
    task: Task,
    worktreePath: WorktreePath,
    previousFeedback?: string,
  ): Promise<Result<WorkerResult, OrchestratorError>> => {
    // 1. runsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç¢ºä¿
    const ensureResult = await deps.runnerEffects.ensureRunsDir();
    if (isErr(ensureResult)) {
      return createErr(ensureResult.err);
    }

    // 2. RunIDç”Ÿæˆï¼ˆã‚¿ã‚¹ã‚¯IDãƒ™ãƒ¼ã‚¹ï¼‰
    const timestamp = Date.now();
    const theRunId = runId(`run-${task.id}-${timestamp}`);
    const logPath = path.join(deps.agentCoordPath, 'runs', `${theRunId}.log`);

    // 3. å®Ÿè¡Œãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
    const run = createInitialRun({
      id: theRunId,
      taskId: task.id,
      agentType: deps.agentType,
      logPath,
      plannerRunId: task.plannerRunId ?? null,
      plannerLogPath: task.plannerLogPath ?? null,
      plannerMetadataPath: task.plannerMetadataPath ?? null,
    });

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä¿å­˜
    const saveMetaResult = await deps.runnerEffects.saveRunMetadata(run);
    if (isErr(saveMetaResult)) {
      return createErr(saveMetaResult.err);
    }

    // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’åˆæœŸåŒ–
    const initLogResult = await deps.runnerEffects.initializeLogFile(run);
    if (isErr(initLogResult)) {
      return createErr(initLogResult.err);
    }

    console.log(`  ğŸ“ Execution log: ${getRunDisplayPath(theRunId, 'log')}`);
    console.log(`  ğŸ“Š Metadata: ${getRunDisplayPath(theRunId, 'json')}`);

    // 4. ãƒ­ã‚°ã«ã‚¿ã‚¹ã‚¯é–‹å§‹ã‚’è¨˜éŒ²
    await deps.runnerEffects.appendLog(
      theRunId,
      `[${new Date().toISOString()}] Starting task: ${task.acceptance}\n`,
    );
    await deps.runnerEffects.appendLog(theRunId, `Agent Type: ${deps.agentType}\n`);
    await deps.runnerEffects.appendLog(theRunId, `Worktree: ${worktreePath} (reused)\n`);

    if (previousFeedback) {
      await deps.runnerEffects.appendLog(
        theRunId,
        `Previous task feedback:\n${previousFeedback}\n\n`,
      );
    }

    // 5. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å®Ÿè¡Œï¼ˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¿½åŠ ï¼‰
    // WHY: task.context ã«ã¯è©³ç´°ãªå®Ÿè£…æŒ‡ç¤ºãŒå«ã¾ã‚Œã‚‹ãŸã‚ã€å¿…ãšãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«å«ã‚ã‚‹
    let agentPrompt = `Execute task: ${task.acceptance}

${task.context ? `## IMPLEMENTATION DETAILS\n${task.context}\n` : ''}
${task.scopePaths.length > 0 ? `## FILES TO CREATE/MODIFY\n${task.scopePaths.join('\n')}\n` : ''}

âš ï¸  CRITICAL: You must IMPLEMENT the task, not just verify it.
- CREATE or MODIFY the files listed above
- If files already exist, verify they meet requirements OR update them
- Ensure your changes are saved and ready to be committed
- The "VERIFY" section describes how to validate completion, not the entire task

âš ï¸  IMPORTANT: You are working in an isolated worktree directory.
- Your working directory is: ${worktreePath}
- DO NOT use 'cd ..' or navigate outside this directory
- All work must be done within this directory
- The worktree is properly configured with the correct branch

âš ï¸  IMPORTANT: DO NOT create report files in the repository
- DO NOT create VERIFICATION_REPORT.md or any other report files
- Output verification results directly to logs (stdout/stderr)
- Use console.log, console.error for verification output
- Reports are automatically saved to the runs/ directory by the orchestrator`;

    if (previousFeedback) {
      agentPrompt += `\n\nPrevious task feedback:\n${previousFeedback}`;
    }

    // Judgeåˆ¤å®šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãŒã‚ã‚‹å ´åˆã¯è¿½åŠ ï¼ˆç¶™ç¶šå®Ÿè¡Œã®ãŸã‚ï¼‰
    // WHY: å‰å›ã®åˆ¤å®šã§æŒ‡æ‘˜ã•ã‚ŒãŸå•é¡Œã‚’æ˜ç¤ºã™ã‚‹ã“ã¨ã§ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒé©åˆ‡ã«å¯¾å‡¦ã§ãã‚‹
    if (task.judgementFeedback) {
      agentPrompt += `\n\nâš ï¸  Previous attempt (iteration ${task.judgementFeedback.iteration}/${task.judgementFeedback.maxIterations}):`;
      agentPrompt += `\nReason: ${task.judgementFeedback.lastJudgement.reason}`;
      if (task.judgementFeedback.lastJudgement.missingRequirements.length > 0) {
        agentPrompt += `\n\nMissing requirements:`;
        for (const req of task.judgementFeedback.lastJudgement.missingRequirements) {
          agentPrompt += `\n  - ${req}`;
        }
      }
      agentPrompt += `\n\nPlease address these issues and complete the task.`;
    }

    const agentResult =
      deps.agentType === 'claude'
        ? await deps.runnerEffects.runClaudeAgent(agentPrompt, worktreePath as string, deps.model!, theRunId)
        : await deps.runnerEffects.runCodexAgent(agentPrompt, worktreePath as string, deps.model, theRunId);

    // 6. çµæœã‚’ãƒ­ã‚°ã«è¨˜éŒ²
    if (isErr(agentResult)) {
      const errorMsg = agentResult.err.message;
      await deps.runnerEffects.appendLog(
        theRunId,
        `[${new Date().toISOString()}] âŒ Agent execution failed\n`,
      );
      await deps.runnerEffects.appendLog(theRunId, `Error: ${errorMsg}\n`);

      // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆå¤±æ•—ï¼‰
      const failedRun = {
        ...run,
        status: RunStatus.FAILURE,
        finishedAt: new Date().toISOString(),
        errorMessage: errorMsg,
      };
      await deps.runnerEffects.saveRunMetadata(failedRun);

      return createOk({
        runId: theRunId,
        success: false,
        error: errorMsg,
      });
    }

    // 7. æˆåŠŸæ™‚ã®å‡¦ç†
    const output = agentResult.val;

    await deps.runnerEffects.appendLog(
      theRunId,
      `[${new Date().toISOString()}] âœ… Agent execution completed\n`,
    );
    await deps.runnerEffects.appendLog(theRunId, `Final Response:\n${output.finalResponse}\n`);

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆæˆåŠŸï¼‰
    const completedRun = {
      ...run,
      status: RunStatus.SUCCESS,
      finishedAt: new Date().toISOString(),
    };
    await deps.runnerEffects.saveRunMetadata(completedRun);

    return createOk({
      runId: theRunId,
      success: true,
    });
  };

  /**
   * ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå…¨ä½“ã®ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
   *
   * 1. worktreeã‚’ä½œæˆï¼ˆä¾å­˜é–¢ä¿‚ã«å¿œã˜ãŸå‡¦ç†ï¼‰
   * 2. ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒã‚ã‚‹å ´åˆã¯ã€ãã®å ´ã§è§£æ±º
   * 3. Workerã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’èµ·å‹•
   * 4. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
   * 5. ãƒªãƒ¢ãƒ¼ãƒˆã«push
   *
   * @param task å®Ÿè¡Œã™ã‚‹ã‚¿ã‚¹ã‚¯
   * @param resolution ãƒ™ãƒ¼ã‚¹ãƒ–ãƒ©ãƒ³ãƒè§£æ±ºçµæœï¼ˆä¾å­˜é–¢ä¿‚ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
   * @returns å®Ÿè¡Œçµæœ
   */
  const executeTaskWithWorktree = async (
    task: Task,
    resolution: BaseBranchResolution,
  ): Promise<Result<WorkerResult, OrchestratorError>> => {
    try {
      // 1. Worktreeã‚’ä½œæˆï¼ˆresolutionã®å‹ã«å¿œã˜ã¦å‡¦ç†ã‚’åˆ†å²ï¼‰
      let setupResult: Result<WorktreeSetupResult, OrchestratorError>;

      switch (resolution.type) {
        case 'none': {
          // ä¾å­˜ãªã—: HEADã‹ã‚‰åˆ†å²
          const noneResult = await setupWorktree(task);
          setupResult = noneResult.ok
            ? createOk({ type: 'success', worktreePath: noneResult.val })
            : noneResult;
          break;
        }
        case 'single': {
          // å˜ä¸€ä¾å­˜: ä¾å­˜å…ˆãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰åˆ†å²
          const singleResult = await setupWorktree(task, resolution.baseBranch);
          setupResult = singleResult.ok
            ? createOk({ type: 'success', worktreePath: singleResult.val })
            : singleResult;
          break;
        }
        case 'multi':
          // è¤‡æ•°ä¾å­˜: worktreeå†…ã§ãƒãƒ¼ã‚¸
          setupResult = await setupWorktreeWithMerge(task, resolution.dependencyBranches);
          break;
      }

      if (isErr(setupResult)) {
        return createErr(setupResult.err);
      }

      const result = setupResult.val;
      let worktreePath: WorktreePath;

      // 2. ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒã‚ã‚‹å ´åˆã¯ã€ãã®å ´ã§è§£æ±º
      // WHY: Workerè‡ªèº«ãŒè§£æ±ºã™ã‚‹ã“ã¨ã§ã€ã‚¿ã‚¹ã‚¯å¤±æ•—â†’ä¾å­˜ãƒ–ãƒ­ãƒƒã‚¯ã®é€£é–ã‚’é˜²ã
      if (result.type === 'with_conflicts') {
        worktreePath = result.worktreePath;
        const { conflictInfo } = result;

        console.log(`  âš ï¸  Merge conflicts detected in ${conflictInfo.conflicts.length} file(s)`);

        // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        const conflictPrompt = buildConflictResolutionPromptInline(conflictInfo);

        // Issue 1: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºç”¨ã®RunIDã‚’ç”Ÿæˆ
        // WHY: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºã®å®Ÿè¡Œå±¥æ­´ã‚’è¿½è·¡å¯èƒ½ã«ã™ã‚‹
        const ensureResult = await deps.runnerEffects.ensureRunsDir();
        if (isErr(ensureResult)) {
          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr(ensureResult.err);
        }

        const conflictResolutionRunId = runId(`conflict-resolution-${task.id}-${Date.now()}`);
        const conflictRun = createInitialRun({
          id: conflictResolutionRunId,
          taskId: task.id,
          agentType: deps.agentType,
          logPath: path.join(deps.agentCoordPath, 'runs', `${conflictResolutionRunId}.log`),
        });

        const saveMetaResult = await deps.runnerEffects.saveRunMetadata(conflictRun);
        if (isErr(saveMetaResult)) {
          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr(saveMetaResult.err);
        }

        const initLogResult = await deps.runnerEffects.initializeLogFile(conflictRun);
        if (isErr(initLogResult)) {
          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr(initLogResult.err);
        }

        console.log(
          `  ğŸ“ Conflict resolution log: ${getRunDisplayPath(conflictResolutionRunId, 'log')}`,
        );

        // Claudeã«ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºã‚’ä¾é ¼
        const resolutionResult =
          deps.agentType === 'claude'
            ? await deps.runnerEffects.runClaudeAgent(
                conflictPrompt,
                worktreePath as string,
                deps.model!,
                conflictResolutionRunId,
              )
            : await deps.runnerEffects.runCodexAgent(
                conflictPrompt,
                worktreePath as string,
                deps.model,
                conflictResolutionRunId,
              );

        if (isErr(resolutionResult)) {
          // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºå¤±æ•—
          console.log(
            `  âŒ Failed to resolve merge conflicts: ${resolutionResult.err.message}`,
          );

          // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆå¤±æ•—ï¼‰
          const failedRun = {
            ...conflictRun,
            status: RunStatus.FAILURE,
            finishedAt: new Date().toISOString(),
            errorMessage: resolutionResult.err.message,
          };
          await deps.runnerEffects.saveRunMetadata(failedRun);

          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr(resolutionResult.err);
        }

        // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆæˆåŠŸï¼‰
        const completedRun = {
          ...conflictRun,
          status: RunStatus.SUCCESS,
          finishedAt: new Date().toISOString(),
        };
        await deps.runnerEffects.saveRunMetadata(completedRun);

        // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºæˆåŠŸ: å¤‰æ›´ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã—ã¦ã‚³ãƒŸãƒƒãƒˆ
        const stageResult = await deps.gitEffects.stageAll(worktreePath);
        if (isErr(stageResult)) {
          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr(stageResult.err);
        }

        // Issue 5: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒãƒ¼ã‚«ãƒ¼ãŒæ®‹ã£ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
        // WHY: LLMãŒè§£æ±ºã«å¤±æ•—ã—ã€ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒãƒ¼ã‚«ãƒ¼ãŒæ®‹ã£ãŸã¾ã¾ã‚³ãƒŸãƒƒãƒˆã•ã‚Œã‚‹ã®ã‚’é˜²ã
        const diffResult = await deps.gitEffects.getDiff(worktreePath, ['--cached']);
        if (isErr(diffResult)) {
          console.log(`  âš ï¸  Failed to check for conflict markers: ${diffResult.err.message}`);
          // diffå–å¾—å¤±æ•—ã¯è‡´å‘½çš„ã§ã¯ãªã„ãŸã‚ã€è­¦å‘Šã®ã¿
        } else {
          const diff = diffResult.val;
          const hasConflictMarkers =
            diff.includes('<<<<<<<') || diff.includes('=======') || diff.includes('>>>>>>>');

          if (hasConflictMarkers) {
            console.log(`  âŒ Conflict markers still present after resolution`);
            await deps.gitEffects.abortMerge(repoPath(worktreePath));
            await cleanupWorktree(task.id);
            return createErr({
              type: 'ValidationError',
              message: 'Conflict resolution incomplete: conflict markers still present',
              details:
                'The agent failed to fully resolve conflicts. Manual intervention is required.',
            });
          }
        }

        const commitResult = await deps.gitEffects.commit(
          worktreePath,
          'Resolve merge conflicts from dependencies',
          { noGpgSign: !deps.config.commit.autoSignature },
        );

        if (isErr(commitResult)) {
          // Issue 2: ã‚³ãƒŸãƒƒãƒˆå¤±æ•—æ™‚ã«ãƒãƒ¼ã‚¸ã‚’ä¸­æ–­
          console.log(`  âŒ Failed to commit conflict resolution: ${commitResult.err.message}`);
          await deps.gitEffects.abortMerge(repoPath(worktreePath));
          await cleanupWorktree(task.id);
          return createErr(commitResult.err);
        }

        console.log(`  âœ… Merge conflicts resolved`);

        // Phase 4: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºå¾Œã«ä¾å­˜é–¢ä¿‚ã®å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆå¿…è¦ãªå ´åˆï¼‰
        if (conflictInfo.needsReinstall) {
          console.log(`  ğŸ“¦ Reinstalling dependencies...`);
          const installResult = await runCommand(worktreePath, 'pnpm', ['install']);
          if (!installResult.ok) {
            console.log(`  âš ï¸  Failed to reinstall dependencies: ${installResult.err.message}`);
            // å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¤±æ•—ã¯è­¦å‘Šã®ã¿ã€ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã¯ç¶™ç¶š
          } else {
            console.log(`  âœ… Dependencies reinstalled`);
          }
        }
      } else {
        worktreePath = result.worktreePath;
      }

      // 3. ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
      const runResult = await executeTask(task, worktreePath);
      if (isErr(runResult)) {
        return createErr(runResult.err);
      }

      const workerResult = runResult.val;

      if (!workerResult.success) {
        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œå¤±æ•—æ™‚ã¯WorkerResultã‚’ãã®ã¾ã¾è¿”ã™
        return createOk(workerResult);
      }

      // 4. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
      const commitResult = await commitChanges(task, worktreePath);
      if (isErr(commitResult)) {
        return createErr(commitResult.err);
      }

      // 5. ãƒªãƒ¢ãƒ¼ãƒˆã«push
      const pushResult = await pushChanges(worktreePath);
      if (isErr(pushResult)) {
        return createErr(pushResult.err);
      }

      return createOk(workerResult);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return createOk({
        runId: `error-${task.id}`,
        success: false,
        error: errorMessage,
      });
    }
  };

  /**
   * æ—¢å­˜worktreeã®çŠ¶æ…‹ã‚’ç¶­æŒã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ç¶šè¡Œ
   *
   * WHY: å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ã€Œç¶šãã‹ã‚‰å¼•ãç¶™ãã€éš›ã€æ—¢å­˜ã®worktreeã¨ãƒ­ã‚°ã‚’åˆ©ç”¨ã—ã¦ç¶šè¡Œã™ã‚‹
   *
   * @param task å®Ÿè¡Œã™ã‚‹ã‚¿ã‚¹ã‚¯
   * @returns å®Ÿè¡Œçµæœ
   */
  const continueTask = async (task: Task): Promise<Result<WorkerResult, OrchestratorError>> => {
    try {
      // 1. æ—¢å­˜worktreeã®å­˜åœ¨ã‚’ç¢ºèªï¼ˆlistWorktreesã‚’ä½¿ç”¨ï¼‰
      const worktreesResult = await deps.gitEffects.listWorktrees(deps.appRepoPath);
      if (isErr(worktreesResult)) {
        console.log(`  âš ï¸  Failed to list worktrees, falling back to normal execution`);
        // ç¶™ç¶šå®Ÿè¡Œã«å¤±æ•—ã—ãŸå ´åˆã¯ã€ä¾å­˜é–¢ä¿‚ãªã—ã¨ã—ã¦é€šå¸¸å®Ÿè¡Œ
        return await executeTaskWithWorktree(task, { type: 'none' });
      }

      const worktrees = worktreesResult.val;
      const taskWorktree = worktrees.find((wt) => {
        // Worktreeã®ãƒ‘ã‚¹ã« task.id ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        return String(wt.path).includes(String(task.id));
      });

      if (!taskWorktree) {
        console.log(
          `  âš ï¸  Worktree for task ${task.id} not found, falling back to normal execution`,
        );
        // ç¶™ç¶šå®Ÿè¡Œã«å¤±æ•—ã—ãŸå ´åˆã¯ã€ä¾å­˜é–¢ä¿‚ãªã—ã¨ã—ã¦é€šå¸¸å®Ÿè¡Œ
        return await executeTaskWithWorktree(task, { type: 'none' });
      }

      const existingWorktreePath = taskWorktree.path;

      // 2. å‰å›ã®å®Ÿè¡Œãƒ­ã‚°ã‚’èª­ã¿è¾¼ã‚€ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
      let previousLog: string | undefined;
      const logFilesResult = await deps.runnerEffects.listRunLogs();
      const logFiles = logFilesResult.ok ? logFilesResult.val : [];

      // ã‚¿ã‚¹ã‚¯IDã«é–¢é€£ã™ã‚‹ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢
      const taskLogs = logFiles.filter((logFile) => logFile.includes(String(task.id)));

      if (taskLogs.length > 0) {
        // æœ€æ–°ã®ãƒ­ã‚°ã‚’å–å¾—ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰.logã‚’é™¤å»ã—ã¦runIdã¨ã—ã¦ä½¿ç”¨ï¼‰
        const latestLogFile = taskLogs[taskLogs.length - 1];
        const runIdStr = latestLogFile?.replace('.log', '') ?? '';

        const logContentResult = await deps.runnerEffects.readLog(runIdStr);
        if (logContentResult.ok) {
          previousLog = logContentResult.val;
          console.log(`  ğŸ“‹ Loaded previous execution log: ${latestLogFile}`);
        }
      }

      // 3. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å®Ÿè¡Œï¼ˆpreviousLogã‚’ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã¨ã—ã¦æ¸¡ã™ï¼‰
      const runResult = await executeTaskInExistingWorktree(
        task,
        existingWorktreePath,
        previousLog,
      );

      if (isErr(runResult)) {
        return createErr(runResult.err);
      }

      const result = runResult.val;

      if (!result.success) {
        return createOk(result);
      }

      // 4. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
      const commitResult = await commitChanges(task, existingWorktreePath);
      if (isErr(commitResult)) {
        return createErr(commitResult.err);
      }

      // 5. ãƒªãƒ¢ãƒ¼ãƒˆã«push
      const pushResult = await pushChanges(existingWorktreePath);
      if (isErr(pushResult)) {
        return createErr(pushResult.err);
      }

      return createOk(result);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return createOk({
        runId: `error-${task.id}`,
        success: false,
        error: errorMessage,
      });
    }
  };

  return {
    setupWorktree,
    executeTask,
    executeTaskInExistingWorktree,
    commitChanges,
    pushChanges,
    cleanupWorktree,
    executeTaskWithWorktree,
    continueTask,
  };
};
